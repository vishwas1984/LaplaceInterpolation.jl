var documenterSearchIndex = {"docs":
[{"location":"#LaplaceInterpolation.jl-Documentation","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"","category":"section"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"This package quickly interpolates data on a grid in one and higher dimensions. ","category":"page"},{"location":"#Installation-Instructions","page":"LaplaceInterpolation.jl Documentation","title":"Installation Instructions","text":"","category":"section"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"This package is unregistered, so please install using","category":"page"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"Pkg> add https://github.com/vishwas1984/LaplaceInterpolation.jl","category":"page"},{"location":"#Getting-started","page":"LaplaceInterpolation.jl Documentation","title":"Getting started","text":"","category":"section"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"Suppose we need to interpolate the following image ","category":"page"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"using LaplaceInterpolation, TestImgaes\n\nimg = Float64.(Gray.(testimage(\"mandrill\")))","category":"page"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"For illustration purposes, we'll punch a few holes and randomize some data","category":"page"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"rows, columns = (256, 512)\nN = rows*columns\n\nmat = convert(Array{Float64}, imgg)[1:rows,1:columns]\n\nN2 = Int64(round(N/2))\nNo_of_nodes_discarded = Int64(round(0.9*N2))\n\ndiscard1 = N2 .+ randperm(N2)[1:No_of_nodes_discarded]\n\ncent = [(150, 150), (60, 100)]\nrad = 30*ones(Int64, 2)\ndiscard2 = punch_holes_2D(cent, rad, rows, columns);\n\ndiscard = vcat(discard1, discard2)\nmat[discard] .= 1\n\nheatmap(mat, title = \"Image with Missing data\", yflip = true, \n              c = :bone, clims = (0.0, 1.0))","category":"page"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"Interpolating using the laplace and matern approximations, we get","category":"page"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"restored_img_laplace = matern_2d_grid(mat, discard, 1, 0.0)\nrestored_img_matern = matern_2d_grid(mat, discard, 2, 0.0)","category":"page"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"And plotting, we have","category":"page"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"p1 = heatmap(mat, title = \"Original Data\", yflip = true, \n              c = :bone, clims = (0.0, 1.0))\np2 = heatmap(holeyimage1, title = \"Image with Missing data\", yflip = true, \n              c = :bone, clims = (0.0, 1.0))\np3 = heatmap(restored_img_laplace, title = \"Laplace Interpolated Image\", yflip =\ntrue, \n              c = :bone, clims = (0.0, 1.0))\np4 = heatmap(restored_img_matern, title = \"Matern, m = 2, eps = 0.0\", yflip =\ntrue, \n              c = :bone, clims = (0.0, 1.0))\nplot(p1, p2, p3, p4, layout = (2, 2), legend = false, size = (900, 500))\n","category":"page"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"(Image: Mandrill_Random)","category":"page"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"The Notebooks folder contains this and other examples. ","category":"page"},{"location":"#Mathematical-Details","page":"LaplaceInterpolation.jl Documentation","title":"Mathematical Details","text":"","category":"section"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"Radial basis functions and splines can be unified conceptually through the notion of Green's functions and eigenfunction expansions (Fasshauer, 2012).  The general multivariate Matern kernels are of the form  [ K(\\mathbf x ; \\mathbf z) = K{m-d/2}(\\epsilon||\\mathbf x -\\mathbf z ||)(ϵ||\\mathbf x - \\mathbf z ||)^{m-d/2}]  for m  d2, where Kν$ is the modified Bessel function of the second kind, and can be obtained as Green’s kernels of  [ L = (ϵ^2I-Δ)^m ] where Δ denotes the Laplacian operator in d dimensions. Polyharmonic splines, including thin plate splines, are a special case of the above, and this class includes the thin plate splines. ","category":"page"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"The discrete gridded interpolation seeks to find an interpolation u (mathbf x ) that satisfies the differential operator in d dimensions on the nodes mathbf x_i where there is no data and equals y_i everywhere else. Discretely, one solves the matrix problem [\\mathbf C  (\\mathbf u  - \\mathbf y ) - (1 - \\mathbf C ) L \\mathbf u  = 0 ] where mathbfy contains the y_i's and placeholders where there is no data, L denotes the discrete matrix operator and  [ C{i,j} = \\left { \\begin{array}{ll} 1 & \\mathbf xi \\mbox{ known, } i = j\\ 0 & \\mbox{otherwise.} \\end{array} \\right. ] indicates whether node mathbf x_i is observed. ","category":"page"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"In d- dimensions the matrix A^(d) of size M times M expands the first order finite difference curvature and has entries [ A^{(d)}{i,j} = \\left { \\begin{array}{ll} -1 & j \\in N(\\mathbf xi) \\\n\\sum{j \\in N(\\mathbf xi)} 1 & j = i \\ 0 & \\mbox{otherwise} \\end{array} \\right.] where mathcal N (mathbf x_i) is the set of neighbors of the node mathbf x_i. Note that if node i is a boundary node, the row A^(d)_i has -1s in the neighboring node spots and the number of such nodes on the diagonal. In general, the rows of A^(d) sum to zero. ","category":"page"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"Denote by L = A^(d) the discrete analog of the Laplacian operator. To use the Matern operator, one substitutes L = B^(d)(m ϵ) = ((A^(d))^m - ϵ^2 I).  Importantly, A is sparse, containing at most 5 nonzero entries per row when d = 2 and 7 nonzero entries per row when d = 3 and so on. The Matern matrix B^(d)(m epsilon) is also sparse, having 2(m+d)-1 nonzero entries per row. The sparsity of the matrix allows for the interpolation to solve in linear time.","category":"page"},{"location":"#Function-Index","page":"LaplaceInterpolation.jl Documentation","title":"Function Index","text":"","category":"section"},{"location":"#One-dimensional","page":"LaplaceInterpolation.jl Documentation","title":"One dimensional","text":"","category":"section"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"nablasq_1d_grid\nmatern_1d_grid","category":"page"},{"location":"#LaplaceInterpolation.nablasq_1d_grid","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.nablasq_1d_grid","text":"nablasq_1d_grid(n, h, bc)\n\nLaplacian matrix on a 1D grid\n\nArguments:\n\n- `n`: Number of points\n- `h`: Aspect ratio\n- `bc`: Boundary conditions (1 implies Neumann BC and 0 implies Do nothing BC)\n\nOutputs:\n\n- discrete Laplacian matrix\n\n\n\n\n\n","category":"function"},{"location":"#LaplaceInterpolation.matern_1d_grid","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.matern_1d_grid","text":"matern_1d_grid(y, idx, m, eps, h)\n\nMatern Interpolation in one dimension\n\nArguments:\n\ny: the vector of y's for which the values are known\nidx: the vector of indices for which values are to be interpolated\nm::Int64 = 1: Matern parameter m\neps = 0.0: Matern parameter eps\nh = 1.0: aspect ratio\nbc: Boundary conditions (1 implies Neumann BC and 0 implies Do nothing BC)\n\nOutputs:\n\nvector of interpolated data\n\nExample:\n\nx = 1:100\nh = x[2] - x[1]\ny = sin.(2 * pi * x * 0.2)\ndiscard = randperm(100)[1:50]\n# Laplace interpolation\ny_lap = matern_1d_grid(y, discard, 1, 0.0, h)\n# Matern interpolation\ny_mat = matern_1d_grid(y, discard, 2, 0.1, h)\n\n\n\n\n\n","category":"function"},{"location":"#Two-dimensional","page":"LaplaceInterpolation.jl Documentation","title":"Two dimensional","text":"","category":"section"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"bdy_nodes\nnablasq_2d_grid\nmatern_2d_grid","category":"page"},{"location":"#LaplaceInterpolation.bdy_nodes","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.bdy_nodes","text":"bdy_nodes(Nx, Ny)\n\nFind the nodes on the boundary of a 2D array of size (Nx, Ny)\n\nArguments\n\nNx::Int64: the number of points in the first dimension\nNy::Int64: the number of points in the second dimension\n\nOutputs\n\nvector containing the indices of coordinates on the boundary of the 2D rectangle\n\n\n\n\n\nbdy_nodes(dims)\n\nBoundary node computation, for arbitrary dimension\n\nArguments\n\ndims::Tuple number of points in each direction, must be ints\n\nOutputs\n\nVector{Int64}: vector containing the indices of coordinates \n\non the boundary of the hyperrectangle volume\n\n\n\n\n\n","category":"function"},{"location":"#LaplaceInterpolation.nablasq_2d_grid","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.nablasq_2d_grid","text":"nablasq_2d_grid(Nx, Ny, h, k, bc)\n\nLaplacian matrix on a 2D grid\n\nArguments:\n\nNx::Int64: Number of points in first dimension\nNy::Int64: Number of points in second dimension\nh::Float64: Aspect ratio in first dimension\nk::Float64: Aspect ratio in second dimension\nbc: Boundary conditions (1 implies Neumann BC and 0 implies Do nothing BC)\n\nOutputs:\n\ndiscrete Laplacian matrix in 2D\n\n\n\n\n\n","category":"function"},{"location":"#LaplaceInterpolation.matern_2d_grid","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.matern_2d_grid","text":"matern_2d_grid(mat, discard, m, eps, h, k)\n\nArguments\n\nmat: the matrix containing the image\nidx: the linear indices of the nodes to be discarded\neps: Matern parameter eps\nm: The Matern exponent (integer)\nh: The aspect ratio in the first dimension\nk: The aspect ratio in the second dimension\nbc: Boundary conditions (1 implies Neumann BC and 0 implies Do nothing BC)\n\nOutputs\n\nmatrix containing the interpolated image\n\nExample:\n\nx = y = 1:30\nh = k = x[2] - x[1]\ny = sin.(2 * pi * x * 0.2) * cos.(2 * pi * y * 0.3)\ndiscard = randperm(900)[1:450]\n\nFor Laplace interpolation\n\ny_lap = matern_2d_grid(y, discard, 1, 0.0, h, k)\n\nFor Matern interpolation\n\ny_mat = matern_2d_grid(y, discard, 2, 0.1, h, k)\n\n\n\n\n\n","category":"function"},{"location":"#Three-diimensional","page":"LaplaceInterpolation.jl Documentation","title":"Three diimensional","text":"","category":"section"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"nablasq_3d_grid\nmatern_3d_grid\nmatern_w_punch\nLaplace_3D_Grid\nParallel_Matern_3DGrid\ninterp_nexus \nspdiagm_nonsquare\nreturn_boundary_nodes\nMatern3D_Grid","category":"page"},{"location":"#LaplaceInterpolation.nablasq_3d_grid","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.nablasq_3d_grid","text":"nablasq_3d_grid(Nx,Ny, Nz, h, k, l, bc)\n\nConstruct the 3D Laplace matrix\n\nArguments\n\nNx::Int64: The number of nodes in the first dimension\nNy::Int64: The number of nodes in the second dimension\nNz::Int64: The number of nodes in the third dimension\nh::Float64: Grid spacing in the first dimension\nk::Float64: Grid spacing in the second dimension\nl::Float64: Grid spacing in the third dimension\nbc: Boundary conditions (1 implies Neumann BC and 0 implies Do nothing BC)\n\nOutputs\n\n-nablasq (discrete Laplacian, real-symmetric positive-definite) on Nx×Ny×Nz grid\n\n\n\n\n\n","category":"function"},{"location":"#LaplaceInterpolation.matern_3d_grid","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.matern_3d_grid","text":"matern_3d_grid(imgg, discard, m, eps, h, k, l, bc)\n\nInterpolates a single punch\n\nArguments\n\nimgg: the matrix containing the image\ndiscard::Union{Vector{CartesianIndex{3}}}, Vector{Int64}}: the linear or     Cartesian indices of the values to be filled \nm::Int64 = 1 : Matern parameter \neps::Float64 = 0.0: Matern parameter eps\nh = 1.0: Aspect ratio in the first dimension\nk = 1.0: Aspect ratio in the second dimension\nl = 1.0: Aspect ratio in the third dimension \nbc: Boundary conditions (1 implies Neumann BC and 0 implies Do nothing BC)\n\nOutputs\n\narray containing the restored image\n\n\n\n\n\n","category":"function"},{"location":"#LaplaceInterpolation.matern_w_punch","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.matern_w_punch","text":"matern_w_punch(imgg, Qh_min, Qh_max, Qk_min, Qk_max, Ql_min, Ql_max, m, eps, h, k, l, symm)\n\nInterpolate, in serial, multiple punches\n\nArguments\n\nimgg: the matrix containing the image\nQh_min, Qh_max, Qk_min, Qk_max, Ql_min, Ql_max::Int64: the extents in h,k,l resp \nm::Int64 = 1 : Matern parameter \neps::Float64 = 0.0: Matern parameter eps\nh = 1.0: Aspect ratio in the first dimension\nk = 1.0: Aspect ratio in the second dimension\nl = 1.0: Aspect ratio in the third dimension \n\nOutputs\n\narray containing the interpolated image\n\nExample\n\nh = k = l = 1.0\nsymm = 'A'\nNx = Ny = Nz = 61\nradius = (0.5, 0.5, 0.5 )\nQh_min = Qk_min = Ql_min = -3.0\nQh_max = Qk_max = Ql_max = 3.0\nxpoints = ypoints = zpoints = LinRange(Qh_min, Qh_max, Nx)\nimgg = rand(Nx, Ny, Nz)\nm = 1\neps = 0.0\ninterp = matern_w_punch(imgg, #Qh_min, Qh_max, Qk_min, Qk_max, Ql_min, Ql_max, radius,\n                      radius, xpoints, ypoints, zpoints, m, eps, \n                      h, k, l, symm)\n\n\n\n\n\n","category":"function"},{"location":"#LaplaceInterpolation.spdiagm_nonsquare","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.spdiagm_nonsquare","text":"spdiagm_nonsquare(m, n, args...)\n\nConstruct a sparse diagonal matrix from pairs of vectors and diagonals. \n\nArguments\n\nm::Int64: First dimension of the output matrix\nn::Int64: Second dimension of the output matrix\nargs::Tuple{T} where T<:Pair{<:Integer,<:AbstractVector} \n\nEach vector arg.second will be placed on the arg.first diagonal. By default (if size=nothing), the matrix is square and its size is inferred from kv, but a non-square size m×n (padded with zeros as needed) can be specified by passing m,n as the first arguments.\n\nOutputs\n\nsparse matrix of size mxn containing the values in args \n\n\n\n\n\n","category":"function"},{"location":"#LaplaceInterpolation.return_boundary_nodes","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.return_boundary_nodes","text":"return_boundary_nodes(xpoints, ypoints, zpoints)\n\n...\n\nArguments\n\nxpoints::Vector{T} where T<:Real: the vector containing the x coordinate\nypoints::Vector{T} where T<:Real: the vector containing the y coordinate\nzpoints::Vector{T} where T<:Real: the vector containing the z coordinate\n\n...\n\n...\n\nOutputs\n\nBoundaryNodes3D::Vector{Int64}: vector containing the indices of coordinates \n\non the boundary of the rectangular 3D volume ...\n\n\n\n\n\n","category":"function"},{"location":"#LaplaceInterpolation.Matern3D_Grid","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.Matern3D_Grid","text":"Matern3D_Grid(xpoints, ypoints, zpoints, imgg, epsilon, radius, h, k, l, m)\n\nUse an approximate Matern operator to interpolate punches of defined radius.\n\n...\n\nArguments\n\nxpoints::Vector{T} where T<:Real: the vector containing the x coordinate\nypoints::Vector{T} where T<:Real: the vector containing the y coordinate\nzpoints::Vector{T} where T<:Real: the vector containing the z coordinate\nimgg: the matrix containing the image\nepsilon: Matern parameter epsilon\nradius::Vector: the tuple containing the punch radii \nh::Float: grid spacing along the x-axis\nk::Float: grid spacing along the y-axis\nl::Float: grid spacing along the z-axis\nm::Int : Matern parameter \n\nOutputs\n\ntuple containing the restored image and the punched image.\n\n...\n\n\n\n\n\n","category":"function"},{"location":"#Arbitrary-dimensions","page":"LaplaceInterpolation.jl Documentation","title":"Arbitrary dimensions","text":"","category":"section"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"nablasq_arb \ninterp","category":"page"},{"location":"#LaplaceInterpolation.nablasq_arb","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.nablasq_arb","text":"nablasq_arb(dims, aspect_ratios)\n\nCompute the interpolating (Laplace) matrix for a volume with given dimensions\n\nArguments\n\ndims::Tuple number of points in each dimension, must be ints\naspect_ratios::Tuple the aspect ratio in each dimension, in units\n\nOutputs\n\nA::Matrix{Float64}: matrix of size prod(dims) containing the Laplacian\n\nNote that the boundary condition is average, and Neumann has not been implemented. \n\n\n\n\n\n","category":"function"},{"location":"#LaplaceInterpolation.interp","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.interp","text":"interp(data, ind, m, eps, aspect_ratios)\n\nCompute a Matern or Laplace interpolation on a multidimensional dataset \n\nArguments\n\ndata::Array: Array containing the data\nind::Array: Array of indices for which the data are to be interpolated\nm::Int64: Matern parameter m (m = 1 for Laplace interpolation)\neps::Float64: Matern parameter epsilon (eps = 0.0 for Laplace)\naspect_ratios::Tuple: Tuple containing the aspect ratios in each of the dimensions\n\nOutputs\n\nu::Array: Array (same size as data) containing the interpolated result. \n\n\n\n\n\n","category":"function"},{"location":"#Spherical-Punching","page":"LaplaceInterpolation.jl Documentation","title":"Spherical Punching","text":"","category":"section"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"punch_holes_3D\npunch_holes_2D\npunch_3d_cart\ncenter_list ","category":"page"},{"location":"#LaplaceInterpolation.punch_holes_3D","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.punch_holes_3D","text":"punch_holes_3D(centers, radius, xpoints, ypoints, zpoints)\n\nPunch holes in a 3D volume dataset\n\nArguments\n\ncenters::Vector{T}: the vector containing the centers of the punches\nradius::Float64: the radius of the punch\nNx::Int64: the number of points in the x-direction, this code is hard-coded to start from one. \nNy::Int64: the number of points in the y-direction\nNz::Int64: the number of points in the z-direction\n\nOutputs\n\nabsolute_indices::Vector{Int64}: vector containing the indices of coordinates \n\ninside the punch\n\n\n\n\n\n","category":"function"},{"location":"#LaplaceInterpolation.punch_holes_2D","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.punch_holes_2D","text":"punch_holes_2D(centers, radius, xpoints, ypoints)\n\nPunch holes in a 2D dataset\n\nArguments\n\ncenters::Union{Vector}: the vector containing the punch centers\nradius::Vector: the tuple containing the punch radii \nNx::Int64: the number of points in the x direction\nNy::Int64: the number of points in the y direction\n\nOutputs\n\nabsolute_indices::Vector{Int64}: vector containing the indices of coordinates \n\ninside the punch\n\n\n\n\n\n","category":"function"}]
}
