var documenterSearchIndex = {"docs":
[{"location":"#LaplaceInterpolation.jl-Documentation","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"","category":"section"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"This package quickly interpolates data on a grid in one and higher dimensions. ","category":"page"},{"location":"#Installation-Instructions","page":"LaplaceInterpolation.jl Documentation","title":"Installation Instructions","text":"","category":"section"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"This package is unregistered, so please install using","category":"page"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"Pkg> add https://github.com/vishwas1984/LaplaceInterpolation.jl","category":"page"},{"location":"#Getting-started","page":"LaplaceInterpolation.jl Documentation","title":"Getting started","text":"","category":"section"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"Suppose we need to interpolate the following image ","category":"page"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"using LaplaceInterpolation, TestImgaes\n\nimg = Float64.(Gray.(testimage(\"mandrill\")))","category":"page"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"For illustration purposes, we'll punch a few holes and randomize some data","category":"page"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"rows, columns = (256, 512)\nN = rows*columns\n\nmat = convert(Array{Float64}, imgg)[1:rows,1:columns]\n\nN2 = Int64(round(N/2))\nNo_of_nodes_discarded = Int64(round(0.9*N2))\n\ndiscard1 = N2 .+ randperm(N2)[1:No_of_nodes_discarded]\n\ncent = [(150, 150), (60, 100)]\nrad = 30*ones(Int64, 2)\ndiscard2 = punch_holes_2D(cent, rad, rows, columns);\n\ndiscard = vcat(discard1, discard2)\nmat[discard] .= 1\n\nheatmap(mat, title = \"Image with Missing data\", yflip = true, \n              c = :bone, clims = (0.0, 1.0))","category":"page"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"Interpolating using the laplace and matern approximations, we get","category":"page"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"restored_img_laplace = matern_2d_grid(mat, discard, 1, 0.0)\nrestored_img_matern = matern_2d_grid(mat, discard, 2, 0.0)","category":"page"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"And plotting, we have","category":"page"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"p1 = heatmap(mat, title = \"Original Data\", yflip = true, \n              c = :bone, clims = (0.0, 1.0))\np2 = heatmap(holeyimage1, title = \"Image with Missing data\", yflip = true, \n              c = :bone, clims = (0.0, 1.0))\np3 = heatmap(restored_img_laplace, title = \"Laplace Interpolated Image\", yflip =\ntrue, \n              c = :bone, clims = (0.0, 1.0))\np4 = heatmap(restored_img_matern, title = \"Matern, m = 2, eps = 0.0\", yflip =\ntrue, \n              c = :bone, clims = (0.0, 1.0))\nplot(p1, p2, p3, p4, layout = (2, 2), legend = false, size = (900, 500))\n","category":"page"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"(Image: Mandrill_Random)","category":"page"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"The Notebooks folder contains this and other examples. ","category":"page"},{"location":"#Mathematical-Details","page":"LaplaceInterpolation.jl Documentation","title":"Mathematical Details","text":"","category":"section"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"Radial basis functions and splines can be unified conceptually through the notion of Green's functions and eigenfunction expansions (Image: (Fasshauer, 2012)).  The general multivariate Matern kernels are of the form $ K(\\mathbf{x}; \\mathbf{z}) = K{m-d/2}(\\epsilon||\\mathbf{x}-\\mathbf{z}||)(\\epsilon||\\mathbf{x}-\\mathbf{z}||)^{m-d/2}, $ for m  d2.  where K{\\nu}$ is the modified Bessel function of the second kind, and can be obtained as Green’s kernels of  $ L = (\\epsilon^2I-\\Delta)^m $ where Delta denotes the Laplacian operator in d dimensions. Polyharmonic splines, including thin plate splines, are a special case of the above, and this class includes the thin plate splines. ","category":"page"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"The discrete gridded interpolation seeks to find an interpolation u(mathbfx) that satisfies the differential operator in d dimensions on the nodes mathbfx_i where there is no data and equals y_i everywhere else. Discretely, one solves the matrix problem $ \\mathbf{C} (\\mathbf{u} - \\mathbf{y}) - (1 - \\mathbf{C}) L \\mathbf{u} = 0 $ where mathbfy contains the y_i's and placeholders where there is no data, L denotes the discrete matrix operator and  $ C{i,j} = \\left { \\begin{array}{ll} 1 & \\mathbf{x}i \\mbox{ known, } i = j\\ 0 & \\mbox{otherwise.} \\end{array} \\right. $ indicates whether node mathbfx_i is observed. ","category":"page"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"In d- dimensions the matrix A^(d) of size M times M expands the first order finite difference curvature and has entries $ A^{(d)}{i,j} = \\left { \\begin{array}{ll} -1 & j \\in N(\\mathbf{x}i) \\\n\\sum{j \\in N(\\mathbf{x}i)} 1 & j = i \\ 0 & \\mbox{otherwise} \\end{array} \\right.$ where mathcalN(mathbfx_i) is the set of neighbors of the node mathbfx_i. Note that if node i is a boundary node, the row A^(d)_i has -1s in the neighboring node spots and the number of such nodes on the diagonal. In general, the rows of A^(d) sum to zero. ","category":"page"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"Denote by L = A^(d) the discrete analog of the Laplacian operator. To use the Matern operator, one substitutes L = B^(d)(m epsilon) = ((A^(d))^m - epsilon^2 I). Importantly, A is sparse, containing at most 5 nonzero entries per row when d = 2 and 7 nonzero entries per row when d = 3 and so on. The Matern matrix B^(d)(m epsilon) is also sparse, having 2(m+d)-1 nonzero entries per row. The sparsity of the matrix allows for the interpolation to solve in linear time.","category":"page"},{"location":"#Function-Index","page":"LaplaceInterpolation.jl Documentation","title":"Function Index","text":"","category":"section"},{"location":"#One-dimensional","page":"LaplaceInterpolation.jl Documentation","title":"One dimensional","text":"","category":"section"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"nablasq_grid\nmatern_1d_grid","category":"page"},{"location":"#LaplaceInterpolation.matern_1d_grid","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.matern_1d_grid","text":"matern1dgrid(y, idx, m, eps, h)\n\nMatern Interpolation in one dimension\n\nArguments:\n\ny: the vector of y's for which the values are known\nidx: the vector of indices for which values are to be interpolated\nm::Int64 = 1: Matern parameter m\neps = 0.0: Matern parameter eps\nh = 1.0: aspect ratio\nbc: Boundary conditions (1 implies Neumann BC and 0 implies Do nothing BC)\n\nOutputs:\n\nvector of interpolated data\n\nExample:\n\nx = 1:100\nh = x[2] - x[1]\ny = sin.(2 * pi * x * 0.2)\ndiscard = randperm(100)[1:50]\n# Laplace interpolation\ny_lap = matern_1d_grid(y, discard, 1, 0.0, h)\n# Matern interpolation\ny_mat = matern_1d_grid(y, discard, 2, 0.1, h)\n\n\n\n\n\n","category":"function"},{"location":"#Two-dimensional","page":"LaplaceInterpolation.jl Documentation","title":"Two dimensional","text":"","category":"section"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"bdy_nodes\nmatern_2d_grid","category":"page"},{"location":"#LaplaceInterpolation.bdy_nodes","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.bdy_nodes","text":"bdy_nodes(Nx, Ny)\n\n...\n\nArguments\n\nNx::Int64: the number of points in the first dimension\nNy::Int64: the number of points in the second dimension\n\n...\n\n...\n\nOutputs\n\nvector containing the indices of coordinates on the boundary of the 2D rectangle\n\n...\n\n\n\n\n\nbdy_nodes(dims)\n\nBoundary node computation, for arbitrary dimension\n\n...\n\nArguments\n\ndims::Tuple number of points in each direction\n\n...\n\n...\n\nOutputs\n\nVector{Int64}: vector containing the indices of coordinates \n\non the boundary of the hyperrectangle volume ...\n\n\n\n\n\n","category":"function"},{"location":"#LaplaceInterpolation.matern_2d_grid","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.matern_2d_grid","text":"matern2dgrid(mat, discard, m, eps, h, k)\n\n...\n\nArguments\n\nmat: the matrix containing the image\nidx: the linear indices of the nodes to be discarded\neps: Matern parameter eps\nm: The Matern exponent (integer)\nh: The aspect ratio in the first dimension\nk: The aspect ratio in the second dimension\nbc: Boundary conditions (1 implies Neumann BC and 0 implies Do nothing BC)\n\nOutputs\n\nmatrix containing the interpolated image\n\nExample:\n\n```<julia-repl> x = y = 1:30 h = k = x[2] - x[1] y = sin.(2 * pi * x * 0.2) * cos.(2 * pi * y * 0.3) discard = randperm(900)[1:450]\n\nLaplace interpolation\n\nylap = matern2d_grid(y, discard, 1, 0.0, h, k)\n\nMatern interpolation\n\nymat = matern2d_grid(y, discard, 2, 0.1, h, k) ...\n\n\n\n\n\n","category":"function"},{"location":"#Three-diimensional","page":"LaplaceInterpolation.jl Documentation","title":"Three diimensional","text":"","category":"section"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"nablasq_3d_grid\nmatern_3d_grid\nmatern_w_punch\nLaplace_3D_Grid\nParallel_Matern_3DGrid\ninterp_nexus \nspdiagm_nonsquare\nreturn_boundary_nodes\nMatern3D_Grid","category":"page"},{"location":"#LaplaceInterpolation.nablasq_3d_grid","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.nablasq_3d_grid","text":"nablasq3dgrid(Nx,Ny)\n\nConstruct the 3D Laplace matrix\n\nArguments\n\nNx::Int64: The number of nodes in the first dimension\nNy::Int64: The number of nodes in the second dimension\nNz::Int64: The number of nodes in the third dimension\nh::Float64: Grid spacing in the first dimension\nk::Float64: Grid spacing in the second dimension\nl::Float64: Grid spacing in the third dimension\nbc: Boundary conditions (1 implies Neumann BC and 0 implies Do nothing BC)\n\nOutputs\n\n-nablasq (discrete Laplacian, real-symmetric positive-definite) on Nx×Ny×Nz grid\n\n\n\n\n\n","category":"function"},{"location":"#LaplaceInterpolation.matern_3d_grid","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.matern_3d_grid","text":"matern3dgrid(imgg, discard, m, eps, h, k, l, bc)\n\nInterpolates a single punch\n\n...\n\nArguments\n\nimgg: the matrix containing the image\ndiscard::Union{Vector{CartesianIndex{3}}}, Vector{Int64}}: the linear or     Cartesian indices of the values to be filled \nm::Int64 = 1 : Matern parameter \neps::Float64 = 0.0: Matern parameter eps\nh = 1.0: Aspect ratio in the first dimension\nk = 1.0: Aspect ratio in the second dimension\nl = 1.0: Aspect ratio in the third dimension \nbc: Boundary conditions (1 implies Neumann BC and 0 implies Do nothing BC)\n\nOutputs\n\narray containing the restored image\n\n...\n\n\n\n\n\n","category":"function"},{"location":"#LaplaceInterpolation.matern_w_punch","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.matern_w_punch","text":"maternwpunch(imgg, Qhmin, Qhmax, Qkmin, Qkmax, Qlmin, Qlmax, m, eps, h, k, l, symm)\n\nInterpolate, in serial, multiple punches\n\n...\n\nArguments\n\nimgg: the matrix containing the image\nQh_min, Qh_max, Qk_min, Qk_max, Ql_min, Ql_max::Int64: the extents in h,k,l resp \nm::Int64 = 1 : Matern parameter \neps::Float64 = 0.0: Matern parameter eps\nh = 1.0: Aspect ratio in the first dimension\nk = 1.0: Aspect ratio in the second dimension\nl = 1.0: Aspect ratio in the third dimension \n\nOutputs\n\narray containing the interpolated image\n\nExample\n\nh = k = l = 1.0\nsymm = 'A'\nNx = Ny = Nz = 61\nradius = (0.5, 0.5, 0.5 )\nQh_min = Qk_min = Ql_min = -3.0\nQh_max = Qk_max = Ql_max = 3.0\nxpoints = ypoints = zpoints = LinRange(Qh_min, Qh_max, Nx)\nimgg = rand(Nx, Ny, Nz)\nm = 1\neps = 0.0\ninterp = matern_w_punch(imgg, #Qh_min, Qh_max, Qk_min, Qk_max, Ql_min, Ql_max, radius,\n                      radius, xpoints, ypoints, zpoints, m, eps, \n                      h, k, l, symm);\n\n...\n\n\n\n\n\n","category":"function"},{"location":"#LaplaceInterpolation.spdiagm_nonsquare","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.spdiagm_nonsquare","text":"spdiagm_nonsquare(m, n, args...)\n\nConstruct a sparse diagonal matrix from Pairs of vectors and diagonals. Each vector arg.second will be placed on the arg.first diagonal. By default (if size=nothing), the matrix is square and its size is inferred from kv, but a non-square size m×n (padded with zeros as needed) can be specified by passing m,n as the first arguments.\n\nArguments\n\nm::Int64: First dimension of the output matrix\nn::Int64: Second dimension of the output matrix\nargs::Tuple{T} where T<:Pair{<:Integer,<:AbstractVector} \n\nOutputs\n\nsparse matrix of size mxn containing the values in args \n\n\n\n\n\n","category":"function"},{"location":"#LaplaceInterpolation.return_boundary_nodes","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.return_boundary_nodes","text":"returnboundarynodes(xpoints, ypoints, zpoints)\n\n...\n\nArguments\n\nxpoints::Vector{T} where T<:Real: the vector containing the x coordinate\nypoints::Vector{T} where T<:Real: the vector containing the y coordinate\nzpoints::Vector{T} where T<:Real: the vector containing the z coordinate\n\n...\n\n...\n\nOutputs\n\nBoundaryNodes3D::Vector{Int64}: vector containing the indices of coordinates \n\non the boundary of the rectangular 3D volume ...\n\n\n\n\n\n","category":"function"},{"location":"#LaplaceInterpolation.Matern3D_Grid","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.Matern3D_Grid","text":"Matern3D_Grid(xpoints, ypoints, zpoints, imgg, epsilon, radius, h, k, l, m)\n\n...\n\nArguments\n\nxpoints::Vector{T} where T<:Real: the vector containing the x coordinate\nypoints::Vector{T} where T<:Real: the vector containing the y coordinate\nzpoints::Vector{T} where T<:Real: the vector containing the z coordinate\nimgg: the matrix containing the image\nepsilon: Matern parameter epsilon\nradius::Vector: the tuple containing the punch radii \nh::Float: grid spacing along the x-axis\nk::Float: grid spacing along the y-axis\nl::Float: grid spacing along the z-axis\nm::Int : Matern parameter \n\nOutputs\n\ntuple containing the restored image and the punched image.\n\n...\n\n\n\n\n\n","category":"function"},{"location":"#Arbitrary-dimensions","page":"LaplaceInterpolation.jl Documentation","title":"Arbitrary dimensions","text":"","category":"section"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"nablasq_arb \ninterp","category":"page"},{"location":"#LaplaceInterpolation.nablasq_arb","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.nablasq_arb","text":"Write the matrix \n\n\n\n\n\n","category":"function"},{"location":"#LaplaceInterpolation.interp","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.interp","text":"Compute the interpolation \n\n\n\n\n\n","category":"function"},{"location":"#Spherical-Punching","page":"LaplaceInterpolation.jl Documentation","title":"Spherical Punching","text":"","category":"section"},{"location":"","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.jl Documentation","text":"punch_holes_3D\npunch_holes_2D\npunch_3d_cart\ncenter_list ","category":"page"},{"location":"#LaplaceInterpolation.punch_holes_3D","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.punch_holes_3D","text":"punchholes3D(centers, radius, xpoints, ypoints, zpoints)\n\n...\n\nArguments\n\ncenters::Vector{T}: the vector containing the centers of the punches\nradius::Float64: the radius of the punch\nNx::Int64: the number of points in the x-direction, this code is hard-coded to start from one. \nNy::Int64: the number of points in the y-direction\nNz::Int64: the number of points in the z-direction\n\n...\n\n...\n\nOutputs\n\nabsolute_indices::Vector{Int64}: vector containing the indices of coordinates \n\ninside the punch ...\n\n\n\n\n\n","category":"function"},{"location":"#LaplaceInterpolation.punch_holes_2D","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.punch_holes_2D","text":"punchholes2D(centers, radius, xpoints, ypoints)\n\n...\n\nArguments\n\ncenters::Union{Vector}: the vector containing the punch centers\nradius::Vector: the tuple containing the punch radii \nNx::Int64: the number of points in the x direction\nNy::Int64: the number of points in the y direction\n\n...\n\n...\n\nOutputs\n\nabsolute_indices::Vector{Int64}: vector containing the indices of coordinates \n\ninside the punch ...\n\n\n\n\n\n","category":"function"},{"location":"#LaplaceInterpolation.center_list","page":"LaplaceInterpolation.jl Documentation","title":"LaplaceInterpolation.center_list","text":"Generate a list of centers\n\nExample\n\nxmin = 0\nxmax = 6\nymin = 0\nymax = 8\nzmin = 0\nzmax = 8\n\ncenters = LaplaceInterpolation.center_list('A', xmin, xmax, ymin, ymax, zmin,\nzmax)\n\n\n\n\n\n","category":"function"}]
}
